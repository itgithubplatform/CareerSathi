import { authOptions } from "@/lib/auth"
import { prisma } from "@/lib/prisma"
import { askVertex } from "@/lib/vertex"
import { getServerSession } from "next-auth"
import { NextResponse } from "next/server"

export async function POST(req: Request) {
    try {
        const data = await req.json() as { name: string, description: string }
        const session = await getServerSession(authOptions)
        if (!session?.user?.id) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
        }
        const userProfile = await prisma.userProfile.findUnique({
            where: {
                userId: session.user.id
            }, select: {
                createdAt: false,
                updatedAt: false,
                id: false,
                userId: false,
                education: true,
                stream: true,
                situation: true,
                environment: true,
                activities: true,
                learningStyles: true,
                uncertainty: true,
                tradeoff: true,
                knownCareer: true,
                preferredIndustries: true
            }
        })
  const prompt = `
You are a 'JSON Roadmap Generator' service. Your one and only function is to take the provided inputs and return a single, valid JSON object.

### INPUTS:
1.  Target Roadmap Description (This provides context):
    "${data.description}"

2.  User Profile (Tailor the roadmap to this person):
    ${JSON.stringify(userProfile)}

### OUTPUT REQUIREMENTS:
1.  **CRITICAL:** You MUST return **ONLY** the valid JSON object.
2.  **DO NOT** include any text, explanations, or conversational chat before or after the JSON.
3.  **DO NOT** wrap the JSON in markdown code blocks (like \`\`\`json).
4.  The output JSON **MUST** match this exact structure:
    {
      "roadmap": {
        "careerPath": "string",
        "skillsToLearn": [ "string (markdown)" ],
        "recommendedProjects": [
          {
            "title": "string",
            "description": "string (markdown)"
          }
        ]
      }
    }
5.  All strings inside the JSON must use double quotes, and any internal double quotes **MUST** be escaped (e.g., \\"example\\").

### CONTENT GUIDELINES (THE "QUALITY" LOGIC):
1.  **Career Path:** The "careerPath" field in the output JSON **MUST** be generated by you (the AI) based on the provided inputs. It should be short and concise.

2.  **Timelines:** Every skill and project **MUST** include a suggested timeline (e.g., "**Est. Time: 1-2 weeks**") as part of its markdown string.

3.  **Personalization:** The roadmap MUST be tailored to the "User Profile", but **this tailoring must be concise.**

4.  **Skill Formatting (Concise):**
    - **DO NOT** write long paragraphs.
    - Each skill in "skillsToLearn" **MUST** be a markdown string with:
    - A **bolded title** (e.g., "**Master Python**"). **Do NOT use a \`##\` heading.**
    - A **single, concise sentence** immediately after the title, explaining what to learn and how (e.g., "Master core Python syntax and OOP principles...").
    - The required timeline.

5.  **Project Formatting (Concise):**
    - **DO NOT** write long paragraphs.
    - Each project in "recommendedProjects" **MUST** have:
    - A clear, **bolded title** (e.g., "**Simple Inventory Manager**"). **Do NOT use a \`##\` heading.**
    - A "description" in markdown that is **one or two concise sentences** explaining the project's goal.
    - The required timeline.

6.  **Neutrality:** Do not default to web development. If the user's inputs are generic (e.g., "learning to code"), provide a foundational roadmap (e.g., Python, DSA, Git, Databases) before suggesting a specialization.
`;
        const rawReply = (await askVertex(prompt)).trim()
        console.log(rawReply);
    
        const match = rawReply.match(/```json\s*([\s\S]*?)```/) || rawReply.match(/\{[\s\S]*\}/);
    
        if (!match) {
            throw new Error("No JSON found in CareerSathi response");
        }
    
        let reply;
        reply = JSON.parse(match[1] ?? match[0]);
        console.log(reply.roadmap.skillsToLearn[0]);
        
        if (reply.roadmap) {
            const roadmap = reply.roadmap
            const newRoadmap = await prisma.roadmap.create({
                data: {
                    careerPath: roadmap.careerPath,
                    skillsToLearn: {
                        create: roadmap.skillsToLearn.map((skill: string) => ({ skill, done: false })),
                    },
                    recommendedProjects: {
                        create: roadmap.recommendedProjects.map((project: any) => ({
                            title: project.title,
                            description: project.description,
                        })),
                    },
                    user: {
                        connect: {
                            id: session.user.id
                        }
                    }
                },
            })
            return NextResponse.json({message:"Roadmap created successfully", roadmapId: newRoadmap.id }, { status: 200 });
        }
        throw new Error("Failed to create roadmap")
    } catch (error) {
        console.log(error);
        
        return NextResponse.json({ error: "Failed to create roadmap" }, { status: 500 })
    }
}